<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VetScan Pro - Dog 3D Scanner v7.4.0 - Blender MCP Import</title>
    <!-- Three.js Core - unpkg CDN (funktioniert garantiert!) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <!-- Three.js Examples - unpkg CDN mit korrekten Pfaden -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .main-viewer {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        #viewer-canvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            background: #0f0f23;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .controls-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .mode-buttons .mode-button:nth-child(5),
        .mode-buttons .mode-button:nth-child(6) {
            grid-column: 1 / -1;
        }

        .mode-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f0f0f0;
        }

        .mode-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .mode-button.active {
            background: #667eea;
            color: white;
        }

        .organ-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
            max-width: 250px;
            display: none;
        }

        .organ-info h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .organ-info p {
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 5px;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
            color: white;
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #667eea;
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .help-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: center;
        }

        .status-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }

        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: lime;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üêï VetScan Pro - Bello 3D Scanner</h1>
            <p>Interaktive 3D-Untersuchung mit medizinischen Visualisierungen</p>
            <p style="font-size: 12px; opacity: 0.7;">Version 7.1.0 - Build 2025.08.24.001</p>
        </header>

        <div class="main-viewer">
            <div id="loading-overlay" class="loading-overlay">
                <div>
                    <div>üêï Lade Bello Modell...</div>
                    <div style="font-size: 12px; opacity: 0.7; margin: 5px 0;">Claude Desktop Import bereit</div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text">0%</div>
                </div>
            </div>

            <div class="controls-panel">
                <h3>üî¨ Untersuchungsmodi</h3>
                <div class="mode-buttons">
                    <button class="mode-button active" onclick="switchVisualization('normal')" title="Standard-Ansicht">
                        üëÅÔ∏è Normal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('xray')" title="R√∂ntgenbild">
                        ü¶¥ R√∂ntgen
                    </button>
                    <button class="mode-button" onclick="switchVisualization('ultrasound')" title="Ultraschall">
                        üì° Ultraschall
                    </button>
                    <button class="mode-button" onclick="switchVisualization('thermal')" title="W√§rmebild">
                        üå°Ô∏è Thermal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('mri')" title="Magnetresonanztomographie">
                        üß† MRT
                    </button>
                    <button class="mode-button" onclick="switchVisualization('ct')" title="Computertomographie - Schichtbildverfahren">
                        üí´ CT-Scan
                    </button>
                </div>
            </div>

            <div id="organ-info" class="organ-info">
                <h4 id="organ-title">K√∂rperbereich</h4>
                <div id="organ-details">
                    <p>Klicken Sie auf einen Bereich des Hundes f√ºr Details.</p>
                </div>
                <button onclick="closeOrganInfo()" style="margin-top: 10px; padding: 5px 10px; background: #f0f0f0; border: none; border-radius: 5px; cursor: pointer;">Schlie√üen</button>
            </div>

            <div class="help-text">
                üñ±Ô∏è Klicken zum Untersuchen ‚Ä¢ Ziehen zum Drehen ‚Ä¢ Scroll zum Zoomen
            </div>

            <div id="viewer-canvas"></div>
            
            <div class="status-badge">v7.3.0</div>
        </div>

        <div class="debug-info" id="debug-info">
            Loading libraries...<br>
            Version: 7.3.0<br>
            Build: 2025.08.24.003
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let belloModel = null;
        let currentVisualization = 'normal';
        let medicalShaders = {};
        let originalMaterials = new Map();
        let loadingProgress = 0;
        const VERSION = '7.3.0';
        const BUILD = '2025.08.24.003';

        // Debug helper
        function debug(message) {
            console.log(`[v${VERSION}] ${message}`);
            const debugEl = document.getElementById('debug-info');
            if (debugEl) {
                debugEl.innerHTML += `<br>${message}`;
                // Keep only last 10 messages
                const lines = debugEl.innerHTML.split('<br>');
                if (lines.length > 10) {
                    debugEl.innerHTML = lines.slice(-10).join('<br>');
                }
            }
        }

        // Robust library loader with multiple fallbacks
        function waitForLibraries(callback, attempts = 0) {
            debug(`Checking libraries (attempt ${attempts + 1})...`);
            
            // Check if all libraries are loaded
            const checks = {
                'THREE': typeof THREE !== 'undefined',
                'OrbitControls': typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined',
                'GLTFLoader': typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined',
                'DRACOLoader': typeof THREE !== 'undefined' && typeof THREE.DRACOLoader !== 'undefined'
            };
            
            debug(`Library status: ${JSON.stringify(checks)}`);
            
            // All libraries loaded successfully
            if (checks.THREE && checks.OrbitControls && checks.GLTFLoader && checks.DRACOLoader) {
                debug('‚úÖ All libraries loaded successfully!');
                callback();
                return;
            }
            
            // Try to fix missing libraries
            if (checks.THREE && !checks.OrbitControls) {
                // OrbitControls might be on window
                if (typeof OrbitControls !== 'undefined') {
                    THREE.OrbitControls = OrbitControls;
                    debug('üì¶ Fixed: OrbitControls from global');
                }
            }
            
            if (checks.THREE && !checks.GLTFLoader) {
                if (typeof GLTFLoader !== 'undefined') {
                    THREE.GLTFLoader = GLTFLoader;
                    debug('üì¶ Fixed: GLTFLoader from global');
                }
            }
            
            if (checks.THREE && !checks.DRACOLoader) {
                if (typeof DRACOLoader !== 'undefined') {
                    THREE.DRACOLoader = DRACOLoader;
                    debug('üì¶ Fixed: DRACOLoader from global');
                }
            }
            
            // Retry after a delay
            if (attempts < 20) { // Try for up to 10 seconds
                setTimeout(() => waitForLibraries(callback, attempts + 1), 500);
            } else {
                debug('‚ùå Failed to load all libraries after 10 seconds');
                document.getElementById('loading-overlay').innerHTML = 
                    '<div style="color: red; padding: 20px;">‚ùå Fehler beim Laden der 3D-Bibliotheken. Bitte Seite neu laden (F5).</div>';
            }
        }

        // Initialize when ready
        // WebSocket Live Reload Support
        function setupLiveReload() {
            debug('Setting up WebSocket live reload...');
            
            // Try multiple WebSocket endpoints
            const wsEndpoints = [
                'ws://localhost:8765',  // MCP Bridge
                'ws://localhost:9876',  // Blender MCP Addon
                'ws://localhost:3000/ws' // Vite dev server
            ];
            
            let ws = null;
            let reconnectAttempts = 0;
            const maxReconnectAttempts = 3;
            
            function connectWebSocket(index = 0) {
                if (index >= wsEndpoints.length) {
                    debug('Live reload not available (no WebSocket server)');
                    return;
                }
                
                const endpoint = wsEndpoints[index];
                
                try {
                    ws = new WebSocket(endpoint);
                    
                    ws.onopen = () => {
                        debug(`‚úÖ Live reload connected to ${endpoint}`);
                        reconnectAttempts = 0;
                    };
                    
                    ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'model_updated' || data.type === 'export_complete') {
                                debug('üîÑ Model updated! Reloading...');
                                
                                // Clear cache and reload model
                                if (belloModel) {
                                    scene.remove(belloModel);
                                    belloModel = null;
                                }
                                
                                // Add timestamp to prevent caching
                                const timestamp = Date.now();
                                const reloadUrl = data.path || 'assets/models/animals/bello/bello_live.glb';
                                
                                const loader = new THREE.GLTFLoader();
                                loader.load(
                                    `${reloadUrl}?t=${timestamp}`,
                                    (gltf) => {
                                        debug('‚úÖ Live model reloaded!');
                                        belloModel = gltf.scene;
                                        
                                        // Apply same setup as initial load
                                        belloModel.traverse((child) => {
                                            if (child.isMesh) {
                                                originalMaterials.set(child, child.material.clone());
                                                child.castShadow = true;
                                                child.receiveShadow = true;
                                            }
                                        });
                                        
                                        // Center and scale
                                        const box = new THREE.Box3().setFromObject(belloModel);
                                        const center = box.getCenter(new THREE.Vector3());
                                        belloModel.position.sub(center);
                                        
                                        const size = box.getSize(new THREE.Vector3());
                                        const maxDim = Math.max(size.x, size.y, size.z);
                                        const scale = 3 / maxDim;
                                        belloModel.scale.setScalar(scale);
                                        
                                        scene.add(belloModel);
                                        
                                        // Re-apply current visualization mode
                                        if (currentVisualization !== 'normal') {
                                            applyVisualizationMode(currentVisualization);
                                        }
                                    },
                                    undefined,
                                    (error) => {
                                        debug(`‚ùå Failed to reload model: ${error}`);
                                    }
                                );
                            }
                        } catch (e) {
                            // Not JSON, ignore
                        }
                    };
                    
                    ws.onerror = () => {
                        // Try next endpoint
                        connectWebSocket(index + 1);
                    };
                    
                    ws.onclose = () => {
                        debug('WebSocket disconnected');
                        
                        // Try to reconnect after delay
                        if (reconnectAttempts < maxReconnectAttempts) {
                            reconnectAttempts++;
                            setTimeout(() => {
                                debug(`Reconnecting... (attempt ${reconnectAttempts})`);
                                connectWebSocket(0);
                            }, 5000);
                        }
                    };
                    
                } catch (e) {
                    // Try next endpoint
                    connectWebSocket(index + 1);
                }
            }
            
            // Start connection attempts
            connectWebSocket();
        }

        window.addEventListener('load', function() {
            debug(`Starting VetScan Pro v${VERSION}...`);
            waitForLibraries(() => {
                debug('üéÆ Initializing 3D scene...');
                init();
                setupLiveReload();  // Add live reload after init
            });
        });

        function init() {
            try {
                setupScene();
                setupCamera();
                setupRenderer();
                setupLights();
                setupControls();
                setupShaders();
                loadBelloModel();
                animate();

                // Resize Handler
                window.addEventListener('resize', onWindowResize);
                debug('‚úÖ Initialization complete');
            } catch (error) {
                debug('‚ùå Initialization error: ' + error.message);
                console.error(error);
            }
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f23);
            debug('Scene created');
        }

        function setupCamera() {
            const container = document.getElementById('viewer-canvas');
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 4);
            debug('Camera configured');
        }

        function setupRenderer() {
            const container = document.getElementById('viewer-canvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            debug('Renderer initialized');
        }

        function setupLights() {
            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Directional Light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Spot Light
            const spotLight = new THREE.SpotLight(0x0099ff, 0.5);
            spotLight.position.set(-5, 5, 5);
            spotLight.angle = Math.PI / 6;
            scene.add(spotLight);
            debug('Lights configured');
        }

        function setupControls() {
            try {
                // Use THREE.OrbitControls which we ensured exists
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 2;
                controls.maxDistance = 20;
                controls.maxPolarAngle = Math.PI / 2;

                // Click Handler
                renderer.domElement.addEventListener('click', onCanvasClick);
                debug('OrbitControls initialized');
            } catch (error) {
                debug('‚ùå OrbitControls error: ' + error.message);
                // Fallback to auto-rotation
                setupFallbackControls();
            }
        }

        function setupFallbackControls() {
            debug('‚ö†Ô∏è Using fallback rotation');
            window.fallbackRotation = true;
        }

        function setupShaders() {
            // Enhanced X-Ray Shader (Medical Grade) - v7.1 Advanced
            medicalShaders.xray = {
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    varying vec2 vUv;
                    uniform float time;
                    
                    // Advanced bone density simulation
                    float getBoneDensity(vec3 pos) {
                        // Spine simulation (higher density in center)
                        float spineDistance = length(pos.xz);
                        float spine = smoothstep(0.3, 0.1, spineDistance) * 0.9;
                        
                        // Rib cage simulation
                        float ribPattern = sin(pos.y * 12.0) * cos(pos.z * 8.0);
                        float ribs = smoothstep(0.0, 0.7, ribPattern) * 0.6;
                        
                        // Skull density (higher at top)
                        float skull = smoothstep(0.6, 1.0, pos.y) * 0.8;
                        
                        // Limb bones (radial density)
                        float limbBones = smoothstep(0.15, 0.05, distance(pos.xz, vec2(0.0))) * 0.7;
                        
                        return clamp(spine + ribs + skull + limbBones, 0.0, 1.0);
                    }
                    
                    // Medical noise for realistic X-Ray texture
                    float medicalNoise(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 1.8);
                        
                        // Calculate bone density at this position
                        float boneDensity = getBoneDensity(vPosition);
                        
                        // Medical X-Ray color grading
                        vec3 softTissue = vec3(0.15, 0.2, 0.3);    // Dark blue-gray
                        vec3 mediumDensity = vec3(0.4, 0.5, 0.6);  // Medium gray
                        vec3 highDensity = vec3(0.85, 0.9, 0.95);  // Bright white (bones)
                        
                        // Multi-level density mapping
                        vec3 baseColor;
                        if (boneDensity < 0.3) {
                            baseColor = mix(softTissue, mediumDensity, boneDensity * 3.33);
                        } else {
                            baseColor = mix(mediumDensity, highDensity, (boneDensity - 0.3) * 1.43);
                        }
                        
                        // Apply Fresnel for edge highlighting
                        vec3 color = mix(baseColor, highDensity, fresnel * 0.3);
                        
                        // Medical film grain effect
                        float grain = medicalNoise(vUv * 200.0 + time * 0.1) * 0.03;
                        color += grain;
                        
                        // Improved alpha for depth and density
                        float alpha = 0.2 + fresnel * 0.4 + boneDensity * 0.6;
                        
                        // Subtle blue tint for medical authenticity
                        color.b += 0.05;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                uniforms: {
                    time: { value: 0.0 }
                }
            };

            // Advanced Ultrasound Shader - v7.1 Medical Grade
            medicalShaders.ultrasound = {
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        
                        // Subtle ultrasound wave distortion
                        vec3 pos = position;
                        pos.y += sin(time * 3.0 + position.x * 8.0 + position.z * 6.0) * 0.008;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    uniform float frequency;
                    uniform float gain;
                    
                    // Advanced noise functions for medical ultrasound
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(mix(hash(i), hash(i + vec2(1,0)), u.x),
                                   mix(hash(i + vec2(0,1)), hash(i + vec2(1,1)), u.x), u.y);
                    }
                    
                    // Simulate tissue acoustic impedance
                    float getAcousticImpedance(vec3 pos) {
                        // Different tissue types have different impedances
                        float soft = noise(pos.xy * 10.0) * 0.3; // Soft tissue
                        float fluid = smoothstep(-0.2, 0.2, pos.y) * 0.8; // Fluid (bladder, heart chambers)
                        float organ = sin(pos.x * 15.0) * sin(pos.z * 12.0) * 0.4; // Organs
                        return clamp(soft + fluid + organ, 0.0, 1.0);
                    }
                    
                    // Doppler effect simulation
                    float getDopplerShift(vec3 pos, vec3 normal) {
                        // Simulate blood flow direction
                        vec3 flowDirection = normalize(vec3(sin(time * 0.5), 0.0, cos(time * 0.5)));
                        float dopplerEffect = dot(normal, flowDirection);
                        return dopplerEffect * 0.5 + 0.5;
                    }
                    
                    void main() {
                        // Ultrasound probe position (scanning from top)
                        vec3 probeDirection = vec3(0.0, -1.0, 0.0);
                        float depth = abs(vPosition.y);
                        
                        // Time-gain compensation (TGC) - deeper = brighter
                        float tgc = 1.0 + depth * gain;
                        
                        // Acoustic impedance for tissue differentiation
                        float impedance = getAcousticImpedance(vPosition);
                        
                        // Multiple scan lines for realistic ultrasound appearance
                        float scanLines = sin(vUv.x * 80.0 + time * 2.0) * 0.1;
                        
                        // Beam focusing effect
                        float beamFocus = 1.0 - smoothstep(0.0, 0.5, abs(vUv.x - 0.5));
                        
                        // Advanced speckle noise pattern
                        vec2 speckleCoord = vUv * 150.0 + time * 0.2;
                        float speckle = noise(speckleCoord) * noise(speckleCoord * 2.0) * 0.4;
                        
                        // Echo strength based on angle and impedance
                        float echoAngle = abs(dot(vNormal, probeDirection));
                        float echoStrength = impedance * echoAngle * beamFocus;
                        
                        // Doppler color overlay (red/blue for blood flow)
                        float doppler = getDopplerShift(vPosition, vNormal);
                        vec3 dopplerColor = mix(vec3(0.0, 0.0, 0.3), vec3(0.3, 0.0, 0.0), doppler);
                        
                        // Attenuation with depth
                        float attenuation = exp(-depth * 0.8);
                        
                        // Base ultrasound coloring (grayscale with blue tint)
                        float intensity = (echoStrength + speckle + scanLines) * tgc * attenuation;
                        intensity = clamp(intensity, 0.0, 1.0);
                        
                        // Medical ultrasound color scheme
                        vec3 baseColor = vec3(intensity * 0.7, intensity * 0.8, intensity);
                        
                        // Add subtle Doppler overlay
                        vec3 finalColor = mix(baseColor, baseColor + dopplerColor, 0.3);
                        
                        // Scan beam indicator
                        float scanBeam = 1.0 - smoothstep(0.0, 0.02, abs(mod(vUv.y + time * 0.15, 1.0) - 0.5));
                        finalColor += vec3(0.1, 0.3, 0.5) * scanBeam;
                        
                        // Medical monitor phosphor glow
                        finalColor = pow(finalColor, vec3(0.8));
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                uniforms: {
                    time: { value: 0.0 },
                    frequency: { value: 5.0 },
                    gain: { value: 1.5 }
                }
            };

            // Thermal Imaging Shader
            medicalShaders.thermal = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float time;
                    
                    vec3 heatmap(float t) {
                        vec3 cold = vec3(0.0, 0.0, 1.0);
                        vec3 cool = vec3(0.0, 1.0, 1.0);
                        vec3 warm = vec3(1.0, 1.0, 0.0);
                        vec3 hot = vec3(1.0, 0.0, 0.0);
                        
                        if (t < 0.33) return mix(cold, cool, t * 3.0);
                        else if (t < 0.66) return mix(cool, warm, (t - 0.33) * 3.0);
                        else return mix(warm, hot, (t - 0.66) * 3.0);
                    }
                    
                    void main() {
                        float heat = (vPosition.y + 1.0) * 0.5;
                        heat += sin(time + vPosition.x * 5.0) * 0.1;
                        heat += sin(time * 1.5 + vPosition.z * 3.0) * 0.1;
                        heat = clamp(heat, 0.0, 1.0);
                        
                        vec3 color = heatmap(heat);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                uniforms: {
                    time: { value: 0 }
                }
            };

            // MRI Shader
            medicalShaders.mri = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float slice;
                    
                    void main() {
                        float intensity = 0.5 + 0.5 * dot(vNormal, vec3(0.0, 1.0, 0.0));
                        
                        // Cross-section effect
                        float sliceEffect = smoothstep(0.0, 0.1, abs(vPosition.y - slice));
                        intensity *= sliceEffect;
                        
                        // Tissue differentiation
                        float tissue1 = sin(vPosition.x * 10.0) * 0.1;
                        float tissue2 = cos(vPosition.z * 8.0) * 0.1;
                        intensity += tissue1 + tissue2;
                        
                        vec3 color = vec3(intensity);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                uniforms: {
                    slice: { value: 0 }
                }
            };

            // Advanced CT Scanner Shader - v7.1 Medical Grade
            medicalShaders.ct = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    uniform float slicePosition;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        vUv = uv;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec2 vUv;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    uniform float slicePosition;
                    uniform float contrast;
                    
                    // Hounsfield Unit simulation for CT imaging
                    float getHounsfieldUnit(vec3 pos) {
                        // Air: -1000 HU, Fat: -100 to -50 HU, Water: 0 HU, Muscle: 10-40 HU, Bone: 700-3000 HU
                        float air = smoothstep(-0.8, -0.6, pos.y) * (-1000.0);
                        float fat = smoothstep(-0.3, 0.0, abs(pos.x)) * (-80.0);
                        float muscle = (sin(pos.x * 12.0) * sin(pos.z * 10.0)) * 25.0;
                        float bone = smoothstep(0.05, 0.15, abs(sin(pos.y * 8.0) * cos(pos.x * 6.0))) * 1500.0;
                        
                        return clamp(air + fat + muscle + bone + 50.0, -1000.0, 3000.0);
                    }
                    
                    // Convert Hounsfield units to grayscale intensity
                    float hounsfieldToGrayscale(float hu) {
                        // Standard CT window: Level 50, Width 400 (for soft tissue)
                        float windowLevel = 50.0;
                        float windowWidth = 400.0;
                        
                        float intensity = (hu - windowLevel + windowWidth/2.0) / windowWidth;
                        return clamp(intensity, 0.0, 1.0);
                    }
                    
                    // Cross-sectional slice simulation
                    float getSliceVisibility(vec3 pos, float slicePos) {
                        float distance = abs(pos.y - slicePos);
                        float thickness = 0.05; // Slice thickness
                        return 1.0 - smoothstep(0.0, thickness, distance);
                    }
                    
                    void main() {
                        // Animated slice position
                        float animatedSlice = slicePosition + sin(time * 0.5) * 0.3;
                        
                        // Get tissue density (Hounsfield units)
                        float hu = getHounsfieldUnit(vPosition);
                        float intensity = hounsfieldToGrayscale(hu);
                        
                        // Cross-sectional slice effect
                        float sliceVis = getSliceVisibility(vPosition, animatedSlice);
                        
                        // Enhance contrast at slice boundaries
                        intensity = mix(intensity * 0.3, intensity, sliceVis);
                        
                        // CT reconstruction artifacts (subtle streaking)
                        float artifact = sin(vUv.x * 60.0 + time) * sin(vUv.y * 40.0 + time * 0.7) * 0.02;
                        intensity += artifact;
                        
                        // Medical CT color mapping
                        vec3 ctColor;
                        if (hu < -500.0) {
                            // Air - black
                            ctColor = vec3(0.0, 0.0, 0.0);
                        } else if (hu < -50.0) {
                            // Fat - dark gray
                            ctColor = vec3(0.2, 0.2, 0.2);
                        } else if (hu < 100.0) {
                            // Soft tissue - medium gray
                            ctColor = vec3(intensity * 0.6);
                        } else {
                            // Bone - bright white
                            ctColor = vec3(0.9, 0.95, 1.0);
                        }
                        
                        // Apply contrast enhancement
                        ctColor = pow(ctColor, vec3(1.0 / (1.0 + contrast * 0.5)));
                        
                        // Slice highlight effect
                        if (sliceVis > 0.8) {
                            ctColor += vec3(0.1, 0.2, 0.3) * sliceVis;
                        }
                        
                        // Medical monitor appearance
                        ctColor = mix(ctColor, ctColor * vec3(0.9, 1.0, 1.1), 0.1);
                        
                        gl_FragColor = vec4(ctColor, 1.0);
                    }
                `,
                uniforms: {
                    time: { value: 0.0 },
                    slicePosition: { value: 0.0 },
                    contrast: { value: 1.0 }
                }
            };
            
            debug('Advanced medical shaders configured (v7.1)');
        }

        function loadBelloModel() {
            updateProgress(10);
            
            // Try to load GLTF model first
            const loader = new THREE.GLTFLoader();
            
            // Configure DRACO decoder (optional, for compressed models)
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            loader.setDRACOLoader(dracoLoader);
            
            // Model URLs in priority order - CREATIVE DOG FROM BLENDER
            const modelUrls = [
                // CREATIVE DOG WITH PARTY ACCESSORIES (highest priority)
                'assets/models/animals/dog/dog_creative.glb',
                
                // NEW DOG MODELS FROM BLENDER EXPORT
                'assets/models/animals/dog/dog_high.glb',
                'assets/models/animals/dog/dog_medium.glb',
                'assets/models/animals/dog/dog_medical.glb',
                
                // REALISTIC models exported from Blender GUI
                'assets/models/animals/bello/bello_realistic_high.glb',
                'assets/models/animals/bello/bello_realistic_medium.glb',
                'assets/models/animals/bello/bello_realistic_low.glb',
                'assets/models/animals/bello/bello_complete.glb',
                'assets/models/animals/bello/bello_live.glb',  // Live export from addon
                
                // Fallback to earlier exports
                'assets/models/animals/bello/bello_high.glb',
                'assets/models/animals/bello/bello_medium.glb',
                'assets/models/animals/bello/bello_medical.glb',
                'assets/models/animals/bello/bello_xray.glb',
                
                // Claude Desktop Export fallbacks
                'models/animals/dog/high/bello_claude_desktop.glb',
                'models/animals/dog/medium/bello_claude_desktop.glb',
                'models/animals/dog/low/bello_claude_desktop.glb',
                'models/animals/dog/bello_claude_desktop.glb',
                
                // Progressive quality fallbacks
                'models/animals/dog/high/bello_main.glb',
                'models/animals/dog/medium/bello_main.glb',
                'models/animals/dog/low/bello_main.glb',
                
                // Legacy paths (compatibility)
                'assets/models/animals/bello/bello_low.glb',
                'assets/models/animals/bello/bello.glb',
                'assets/models/bello.glb',
                'models/bello.glb'
            ];
            
            let modelLoadAttempt = 0;
            
            function tryLoadModel() {
                if (modelLoadAttempt >= modelUrls.length) {
                    debug('‚ö†Ô∏è No Claude Desktop GLB found, using advanced procedural dog');
                    debug('üí° To import real model: Place bello_claude_desktop.glb in models/animals/dog/');
                    createProceduralDog();
                    return;
                }
                
                const url = modelUrls[modelLoadAttempt];
                debug(`Attempting to load: ${url}`);
                updateProgress(20 + modelLoadAttempt * 10);
                
                loader.load(
                    url,
                    function(gltf) {
                        debug(`‚úÖ Claude Desktop Model loaded: ${url}`);
                        belloModel = gltf.scene;
                        
                        // Detailed model information
                        let meshCount = 0;
                        let triangleCount = 0;
                        belloModel.traverse((child) => {
                            if (child.isMesh) {
                                meshCount++;
                                if (child.geometry) {
                                    const geo = child.geometry;
                                    triangleCount += geo.index ? geo.index.count / 3 : geo.attributes.position.count / 3;
                                }
                            }
                        });
                        
                        debug(`üìä Model Stats: ${meshCount} meshes, ~${Math.round(triangleCount)} triangles`);
                        debug(`üé® Source: Claude Desktop Export - Professional Quality`);
                        
                        // Store original materials
                        belloModel.traverse((child) => {
                            if (child.isMesh) {
                                originalMaterials.set(child, child.material.clone());
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Center and scale
                        const box = new THREE.Box3().setFromObject(belloModel);
                        const center = box.getCenter(new THREE.Vector3());
                        belloModel.position.sub(center);
                        
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 3 / maxDim;
                        belloModel.scale.setScalar(scale);
                        
                        scene.add(belloModel);
                        updateProgress(100);
                        hideLoadingOverlay();
                    },
                    function(xhr) {
                        const percent = (xhr.loaded / xhr.total * 100);
                        updateProgress(20 + modelLoadAttempt * 10 + percent * 0.7);
                    },
                    function(error) {
                        debug(`Failed to load ${url}`);
                        modelLoadAttempt++;
                        tryLoadModel();
                    }
                );
            }
            
            tryLoadModel();
        }

        function createProceduralDog() {
            debug('üêï Creating advanced Bello model with anatomical structures...');
            const dogGroup = new THREE.Group();
            dogGroup.name = 'Bello';
            
            // === ANATOMICAL SYSTEMS ===
            
            // 1. SKELETAL SYSTEM (INVISIBLE BASE STRUCTURE)
            const skeletalSystem = new THREE.Group();
            skeletalSystem.name = 'SkeletalSystem';
            
            // Spine (main structural support)
            const spineGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.0, 8);
            spineGeometry.rotateZ(Math.PI / 2);
            const spineMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF, // White for bone
                transparent: true,
                opacity: 0.0 // Invisible in normal mode
            });
            const spine = new THREE.Mesh(spineGeometry, spineMaterial);
            spine.position.set(0, 0, 0);
            spine.name = 'Spine';
            skeletalSystem.add(spine);
            
            // Rib cage structure
            for (let i = 0; i < 12; i++) {
                const ribGeometry = new THREE.TorusGeometry(0.4 + i * 0.02, 0.02, 4, 16, Math.PI);
                const rib = new THREE.Mesh(ribGeometry, spineMaterial.clone());
                rib.position.set(-0.5 + i * 0.15, 0.1, 0);
                rib.rotation.y = Math.PI / 2;
                rib.name = `Rib_${i + 1}`;
                skeletalSystem.add(rib);
            }
            
            // Skull structure
            const skullGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const skull = new THREE.Mesh(skullGeometry, spineMaterial.clone());
            skull.position.set(1.2, 0.3, 0);
            skull.name = 'Skull';
            skeletalSystem.add(skull);
            
            dogGroup.add(skeletalSystem);
            
            // 2. ORGAN SYSTEM (HEART, LUNGS, LIVER)
            const organSystem = new THREE.Group();
            organSystem.name = 'OrganSystem';
            
            // Heart
            const heartGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            heartGeometry.scale(1.2, 1.0, 0.8);
            const heartMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF0000,
                transparent: true,
                opacity: 0.0, // Invisible in normal mode
                emissive: 0x330000,
                emissiveIntensity: 0.1
            });
            const heart = new THREE.Mesh(heartGeometry, heartMaterial);
            heart.position.set(0.3, 0.1, -0.1);
            heart.name = 'Heart';
            organSystem.add(heart);
            
            // Lungs (left and right)
            const lungGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            lungGeometry.scale(0.8, 1.2, 1.5);
            const lungMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF69B4,
                transparent: true,
                opacity: 0.0,
                emissive: 0x331122,
                emissiveIntensity: 0.1
            });
            
            const leftLung = new THREE.Mesh(lungGeometry, lungMaterial);
            leftLung.position.set(0.1, 0.2, -0.3);
            leftLung.name = 'LeftLung';
            organSystem.add(leftLung);
            
            const rightLung = new THREE.Mesh(lungGeometry, lungMaterial.clone());
            rightLung.position.set(0.1, 0.2, 0.3);
            rightLung.name = 'RightLung';
            organSystem.add(rightLung);
            
            // Liver
            const liverGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            liverGeometry.scale(1.5, 0.6, 1.2);
            const liverMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513,
                transparent: true,
                opacity: 0.0,
                emissive: 0x2A1A00,
                emissiveIntensity: 0.1
            });
            const liver = new THREE.Mesh(liverGeometry, liverMaterial);
            liver.position.set(-0.2, -0.1, 0);
            liver.name = 'Liver';
            organSystem.add(liver);
            
            // Stomach
            const stomachGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            stomachGeometry.scale(1.3, 0.8, 1.0);
            const stomachMaterial = new THREE.MeshPhongMaterial({
                color: 0x9ACD32,
                transparent: true,
                opacity: 0.0,
                emissive: 0x2A3300,
                emissiveIntensity: 0.1
            });
            const stomach = new THREE.Mesh(stomachGeometry, stomachMaterial);
            stomach.position.set(-0.3, -0.2, 0);
            stomach.name = 'Stomach';
            organSystem.add(stomach);
            
            dogGroup.add(organSystem);
            
            // 3. EXTERNAL BODY STRUCTURE
            
            // Enhanced Body (main torso)
            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            bodyGeometry.scale(1.4, 0.9, 0.95);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B6F47,
                emissive: 0x2D1B0F,
                emissiveIntensity: 0.05
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0;
            body.castShadow = true;
            body.receiveShadow = true;
            body.name = 'Body';
            dogGroup.add(body);
            
            // Head with better proportions
            const headGeometry = new THREE.SphereGeometry(0.65, 32, 32);
            headGeometry.scale(0.95, 0.9, 1.15);
            const headMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B6F47,
                emissive: 0x2D1B0F,
                emissiveIntensity: 0.05
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.35, 0.35, 0);
            head.castShadow = true;
            head.receiveShadow = true;
            head.name = 'Head';
            dogGroup.add(head);
            
            // Enhanced snout with nostril details
            const snoutGeometry = new THREE.CapsuleGeometry(0.15, 0.5, 4, 8);
            snoutGeometry.rotateZ(-Math.PI / 2);
            const snoutMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5C4A3A,
                emissive: 0x1A1410,
                emissiveIntensity: 0.02
            });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(1.8, 0.25, 0);
            snout.name = 'Snout';
            dogGroup.add(snout);
            
            // Nose
            const noseGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const noseMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x000000,
                emissive: 0x111111,
                emissiveIntensity: 0.2
            });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(2.05, 0.3, 0);
            nose.name = 'Nose';
            dogGroup.add(nose);
            
            // Floppy ears (Labrador style)
            const earGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            earGeometry.scale(0.6, 1.0, 0.3);
            const earMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x5C4A3A,
                emissive: 0x1A1410,
                emissiveIntensity: 0.02
            });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(1.0, 0.6, -0.4);
            leftEar.rotation.set(0.3, 0, -0.4);
            leftEar.name = 'LeftEar';
            dogGroup.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial.clone());
            rightEar.position.set(1.0, 0.6, 0.4);
            rightEar.rotation.set(0.3, 0, 0.4);
            rightEar.name = 'RightEar';
            dogGroup.add(rightEar);
            
            // Expressive eyes with highlights
            const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2B1F1A,
                emissive: 0x0F0A08,
                emissiveIntensity: 0.3
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(1.45, 0.45, -0.22);
            leftEye.name = 'LeftEye';
            dogGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            rightEye.position.set(1.45, 0.45, 0.22);
            rightEye.name = 'RightEye';
            dogGroup.add(rightEye);
            
            // Eye highlights for liveliness
            const highlightGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const highlightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.8
            });
            
            const leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            leftHighlight.position.set(1.52, 0.50, -0.20);
            leftHighlight.name = 'LeftEyeHighlight';
            dogGroup.add(leftHighlight);
            
            const rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial.clone());
            rightHighlight.position.set(1.52, 0.50, 0.20);
            rightHighlight.name = 'RightEyeHighlight';
            dogGroup.add(rightHighlight);
            
            // More realistic legs with paws
            const legGeometry = new THREE.CapsuleGeometry(0.12, 0.7, 4, 8);
            const legMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x7A5F3F,
                emissive: 0x251C14,
                emissiveIntensity: 0.03
            });
            
            const legPositions = [
                { pos: [0.6, -0.6, -0.35], name: 'FrontLeftLeg' },
                { pos: [0.6, -0.6, 0.35], name: 'FrontRightLeg' },
                { pos: [-0.6, -0.6, -0.35], name: 'BackLeftLeg' },
                { pos: [-0.6, -0.6, 0.35], name: 'BackRightLeg' }
            ];
            
            legPositions.forEach(legData => {
                const leg = new THREE.Mesh(legGeometry, legMaterial.clone());
                leg.position.set(...legData.pos);
                leg.castShadow = true;
                leg.name = legData.name;
                dogGroup.add(leg);
                
                // Add paws
                const pawGeometry = new THREE.SphereGeometry(0.15, 12, 12);
                pawGeometry.scale(1.0, 0.6, 1.2);
                const pawMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4A3429,
                    emissive: 0x1A110A,
                    emissiveIntensity: 0.02
                });
                const paw = new THREE.Mesh(pawGeometry, pawMaterial);
                paw.position.set(legData.pos[0], legData.pos[1] - 0.45, legData.pos[2]);
                paw.name = legData.name.replace('Leg', 'Paw');
                dogGroup.add(paw);
            });
            
            // Animated tail
            const tailGeometry = new THREE.CapsuleGeometry(0.08, 0.9, 4, 8);
            tailGeometry.rotateZ(Math.PI / 4);
            const tailMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x6B5637,
                emissive: 0x201A11,
                emissiveIntensity: 0.02
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-1.5, 0.3, 0);
            tail.name = 'Tail';
            dogGroup.add(tail);
            
            // === MEDICAL VISUALIZATION MARKERS ===
            
            // Create invisible markers for anatomical regions
            const createMarker = (name, position, size = 0.1) => {
                const markerGeometry = new THREE.SphereGeometry(size, 8, 8);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.0,
                    visible: false
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(...position);
                marker.name = `Marker_${name}`;
                marker.userData = { 
                    isAnatomyMarker: true, 
                    organName: name,
                    medicalInfo: getMedicalInfo(name)
                };
                return marker;
            };
            
            // Add anatomical markers
            const markers = [
                { name: 'Heart', pos: [0.3, 0.1, -0.1] },
                { name: 'LeftLung', pos: [0.1, 0.2, -0.3] },
                { name: 'RightLung', pos: [0.1, 0.2, 0.3] },
                { name: 'Liver', pos: [-0.2, -0.1, 0] },
                { name: 'Stomach', pos: [-0.3, -0.2, 0] },
                { name: 'Spine', pos: [0, 0, 0] },
                { name: 'Head', pos: [1.35, 0.35, 0] },
                { name: 'Chest', pos: [0.2, 0.0, 0] }
            ];
            
            markers.forEach(markerData => {
                const marker = createMarker(markerData.name, markerData.pos);
                dogGroup.add(marker);
            });
            
            // Store original materials for all meshes
            dogGroup.traverse((child) => {
                if (child.isMesh && child.material) {
                    originalMaterials.set(child, child.material.clone());
                }
            });
            
            belloModel = dogGroup;
            scene.add(belloModel);
            
            // Add subtle idle animation
            function animateBello() {
                if (belloModel) {
                    const time = Date.now() * 0.001;
                    
                    // Breathing effect
                    const breathScale = 1 + Math.sin(time * 3) * 0.02;
                    const bodyMesh = belloModel.getObjectByName('Body');
                    if (bodyMesh) {
                        bodyMesh.scale.set(1.4, 0.9 * breathScale, 0.95);
                    }
                    
                    // Tail wagging
                    const tailMesh = belloModel.getObjectByName('Tail');
                    if (tailMesh) {
                        tailMesh.rotation.y = Math.sin(time * 4) * 0.3;
                    }
                    
                    // Eye blink (occasional)
                    const leftEye = belloModel.getObjectByName('LeftEye');
                    const rightEye = belloModel.getObjectByName('RightEye');
                    if (leftEye && rightEye && Math.random() < 0.002) {
                        const blinkScale = Math.sin(time * 20) * 0.5 + 0.5;
                        leftEye.scale.y = blinkScale;
                        rightEye.scale.y = blinkScale;
                        setTimeout(() => {
                            leftEye.scale.y = 1;
                            rightEye.scale.y = 1;
                        }, 200);
                    }
                }
                requestAnimationFrame(animateBello);
            }
            
            // Start animation
            animateBello();
            
            updateProgress(100);
            hideLoadingOverlay();
            debug('‚úÖ Advanced Bello model created with anatomical structures!');
            debug(`üìä Total meshes: ${dogGroup.children.length}`);
            debug(`üî¨ Anatomical markers: ${markers.length}`);
        }

        function updateProgress(percent) {
            loadingProgress = percent;
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            if (progressFill) progressFill.style.width = percent + '%';
            if (progressText) progressText.textContent = Math.round(percent) + '%';
        }

        function hideLoadingOverlay() {
            setTimeout(() => {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) overlay.style.display = 'none';
                debug('Ready for interaction');
            }, 500);
        }

        function switchVisualization(mode) {
            currentVisualization = mode;
            debug(`Switching to ${mode} mode`);
            
            // Update button states
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (!belloModel) return;
            
            // Apply visualization
            belloModel.traverse((child) => {
                if (child.isMesh) {
                    if (mode === 'normal') {
                        child.material = originalMaterials.get(child) || child.material;
                    } else if (medicalShaders[mode]) {
                        const shaderMaterial = new THREE.ShaderMaterial({
                            vertexShader: medicalShaders[mode].vertexShader,
                            fragmentShader: medicalShaders[mode].fragmentShader,
                            uniforms: medicalShaders[mode].uniforms || {},
                            transparent: medicalShaders[mode].transparent || false,
                            side: medicalShaders[mode].side || THREE.FrontSide
                        });
                        child.material = shaderMaterial;
                    }
                }
            });
        }

        function onCanvasClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            if (belloModel) {
                const intersects = raycaster.intersectObject(belloModel, true);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    showOrganInfo(point);
                }
            }
        }

        // Enhanced Medical Information System v7.1
        function showOrganInfo(point) {
            const organInfo = document.getElementById('organ-info');
            const organTitle = document.getElementById('organ-title');
            const organDetails = document.getElementById('organ-details');
            
            // Determine body region based on click position with higher precision
            let region = 'K√∂rper';
            let details = '';
            
            // Get current visualization mode for specialized information
            const mode = currentVisualization;
            
            if (point.y > 0.5) {
                region = 'üß† Kopf & Neurologie';
                details = getHeadDetails(mode);
            } else if (point.y > 0.1 && point.x > -0.2 && point.x < 0.4) {
                region = 'üíì Herz-Kreislauf-System';
                details = getCardiacDetails(mode);
            } else if (point.y > 0.1) {
                region = 'ü´Å Respirationssystem';
                details = getRespiratoryDetails(mode);
            } else if (point.y > -0.3 && Math.abs(point.x) < 0.3) {
                region = 'üè• Abdomen & Verdauung';
                details = getAbdominalDetails(mode);
            } else if (point.y > -0.3) {
                region = 'ü©ª Wirbels√§ule & R√ºcken';
                details = getSpinalDetails(mode);
            } else {
                region = 'ü¶¥ Extremit√§ten & Skelett';
                details = getLimbDetails(mode);
            }
            
            organTitle.textContent = region;
            organDetails.innerHTML = details;
            organInfo.style.display = 'block';
        }

        function getHeadDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>ü¶¥ Sch√§delknochen:</strong> Normale Dichte, keine Frakturen</p>
                        <p><strong>ü¶∑ Z√§hne:</strong> Vollst√§ndiges Gebiss, keine Karies</p>
                        <p><strong>üß† Sch√§delbasis:</strong> Keine Verkalkungen</p>
                        <p><em>Hounsfield-Werte: Knochen 800-1200 HU</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>üß† Gehirn:</strong> Normale Echostruktur</p>
                        <p><strong>üëÅÔ∏è Aug√§pfel:</strong> Klare Strukturen</p>
                        <p><strong>üó£Ô∏è Weichteile:</strong> Homogene Echogenit√§t</p>
                        <p><em>Doppler: Zerebrale Durchblutung normal</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è Kopftemperatur:</strong> 38.2¬∞C (normal)</p>
                        <p><strong>üëÇ Ohren:</strong> 37.8¬∞C, keine Hyperthermie</p>
                        <p><strong>üëÉ Nase:</strong> K√ºhl, gute Durchblutung</p>
                        <p><em>Temperaturverteilung physiologisch</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>üß† Graue Substanz:</strong> T1/T2 normal</p>
                        <p><strong>üß† Wei√üe Substanz:</strong> Keine L√§sionen</p>
                        <p><strong>üíß Liquor:</strong> Normaler Fluss</p>
                        <p><em>FLAIR-Sequenz: Keine Pathologien</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>üß† Hirngewebe:</strong> 35-45 HU (normal)</p>
                        <p><strong>üíÄ Knochen:</strong> 1000+ HU, intakt</p>
                        <p><strong>ü©∏ Gef√§√üe:</strong> Keine Blutungen</p>
                        <p><em>Kontrastmittel: Normale Anreicherung</em></p>
                    `;
                default:
                    return `
                        <p><strong>üß† Neurologie:</strong> Reflexe intakt</p>
                        <p><strong>üëÅÔ∏è Augen:</strong> Pupillenreaktion positiv</p>
                        <p><strong>üëÇ Ohren:</strong> Keine Entz√ºndungen</p>
                        <p><strong>ü¶∑ Gebiss:</strong> Vollst√§ndig, gesund</p>
                    `;
            }
        }

        function getCardiacDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>üíì Herzschatten:</strong> Normal gro√ü, VHS 9.5v</p>
                        <p><strong>ü´Å Lungengef√§√üe:</strong> Normale Zeichnung</p>
                        <p><strong>ü¶¥ Thorax:</strong> Symmetrische Rippenb√∂gen</p>
                        <p><em>Herzspitze nicht vergr√∂√üert</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>üíì Herzfunktion:</strong> EF 65%, normal</p>
                        <p><strong>üö™ Klappen:</strong> Mitral/Aortal intakt</p>
                        <p><strong>ü©∏ Doppler:</strong> Fluss 1.2 m/s</p>
                        <p><em>Wandbewegung synchron</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è Herz:</strong> 39.1¬∞C (aktiv)</p>
                        <p><strong>ü´Å Thorax:</strong> 38.5¬∞C gleichm√§√üig</p>
                        <p><strong>ü©∏ Durchblutung:</strong> Optimal</p>
                        <p><em>Keine Minderperfusion</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>üíì Myokard:</strong> T1/T2 homogen</p>
                        <p><strong>ü´Ä Kammern:</strong> Normale Gr√∂√üe</p>
                        <p><strong>ü©∏ Perfusion:</strong> Gleichm√§√üig</p>
                        <p><em>Keine Fibrose oder Narben</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>üíì Herzmuskel:</strong> 45-55 HU</p>
                        <p><strong>ü´Ä Koronararterien:</strong> Kein Kalk</p>
                        <p><strong>ü´Å Mediastinum:</strong> Normal</p>
                        <p><em>Calcium-Score: 0</em></p>
                    `;
                default:
                    return `
                        <p><strong>üíì Herzfrequenz:</strong> 85 BPM, rhythmisch</p>
                        <p><strong>ü©∫ Herzger√§usche:</strong> Rein, kr√§ftig</p>
                        <p><strong>üíâ Puls:</strong> Kr√§ftig, regelm√§√üig</p>
                        <p><strong>ü©∏ Kreislauf:</strong> Stabil</p>
                    `;
            }
        }

        function getRespiratoryDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>ü´Å Lungenfeld:</strong> Beidseitig bel√ºftet</p>
                        <p><strong>ü¶¥ Rippen:</strong> Intakt, keine Frakturen</p>
                        <p><strong>ü´Å Zwerchfell:</strong> Normal gew√∂lbt</p>
                        <p><em>Keine Pneumonie oder √ñdeme</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>ü´Å Pleura:</strong> Gleitende Bewegung</p>
                        <p><strong>üíß Erguss:</strong> Nicht nachweisbar</p>
                        <p><strong>üîç B-Linien:</strong> Physiologisch</p>
                        <p><em>Lungenparenchym nicht einsehbar</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è Lungentemp:</strong> 38.6¬∞C</p>
                        <p><strong>üå¨Ô∏è Atemluft:</strong> 35.2¬∞C</p>
                        <p><strong>ü¶¥ Thoraxwand:</strong> 38.0¬∞C</p>
                        <p><em>Normale W√§rmeverteilung</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>ü´Å Lungengewebe:</strong> Signal niedrig</p>
                        <p><strong>ü´Ä Herzlunge:</strong> Klare Abgrenzung</p>
                        <p><strong>ü©∏ Gef√§√üe:</strong> Pulmonalarterien normal</p>
                        <p><em>T2-Gewichtung unauff√§llig</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>ü´Å Lungenparenchym:</strong> -800 HU</p>
                        <p><strong>ü©∏ Pulmonalgef√§√üe:</strong> Kontrastiert</p>
                        <p><strong>ü¶¥ Thoraxwand:</strong> 800+ HU</p>
                        <p><em>Keine Embolien oder Infarkte</em></p>
                    `;
                default:
                    return `
                        <p><strong>ü´Å Atmung:</strong> 22/min, regelm√§√üig</p>
                        <p><strong>ü©∫ Auskultation:</strong> Vesikul√§ratmen</p>
                        <p><strong>üìä SpO2:</strong> 98%, normal</p>
                        <p><strong>üå¨Ô∏è Atemwege:</strong> Frei</p>
                    `;
            }
        }

        function getAbdominalDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>üçñ Magen:</strong> Normale Gr√∂√üe und Lage</p>
                        <p><strong>üíß Darmgas:</strong> Physiologisch verteilt</p>
                        <p><strong>ü¶¥ Wirbels√§ule:</strong> LWS intakt</p>
                        <p><em>Keine Obstruktion sichtbar</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>ü´ò Leber:</strong> Homogen, normale Gr√∂√üe</p>
                        <p><strong>ü´ò Nieren:</strong> Beidseitig 6.2cm</p>
                        <p><strong>ü´Ä Aorta:</strong> 1.8cm Durchmesser</p>
                        <p><em>Gallenblase: Wanddicke 2mm</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è Bauchtemp:</strong> 38.8¬∞C</p>
                        <p><strong>ü´ò Leber:</strong> 39.2¬∞C (metabolisch aktiv)</p>
                        <p><strong>ü´ò Nieren:</strong> 38.9¬∞C</p>
                        <p><em>Normale Organtemperaturen</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>ü´ò Leber:</strong> T1/T2 Signal normal</p>
                        <p><strong>ü´ò Pankreas:</strong> Homogene Struktur</p>
                        <p><strong>ü´ò Nieren:</strong> Kortikomedull√§re Diff.</p>
                        <p><em>MRCP: Gallenwege unauff√§llig</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>ü´ò Leber:</strong> 55-65 HU, homogen</p>
                        <p><strong>ü´ò Nieren:</strong> 30-40 HU</p>
                        <p><strong>ü´ò Milz:</strong> 45-55 HU</p>
                        <p><em>Kontrastphasen normal</em></p>
                    `;
                default:
                    return `
                        <p><strong>ü´ò Abdomen:</strong> Weich, nicht schmerzhaft</p>
                        <p><strong>ü´ò Leber:</strong> Nicht vergr√∂√üert</p>
                        <p><strong>ü´ò Nieren:</strong> Beide palpabel</p>
                        <p><strong>üçΩÔ∏è Verdauung:</strong> Normal</p>
                    `;
            }
        }

        function getSpinalDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>ü¶¥ Wirbel:</strong> Normal ausgerichtet</p>
                        <p><strong>üíø Bandscheiben:</strong> H√∂he erhalten</p>
                        <p><strong>ü¶¥ Facettengelenke:</strong> Intakt</p>
                        <p><em>Keine Spondylose</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>üí™ R√ºckenmuskulatur:</strong> Homogen</p>
                        <p><strong>üß† Spinalkanal:</strong> Echoarm</p>
                        <p><strong>ü¶¥ Dornforts√§tze:</strong> Darstellbar</p>
                        <p><em>Begrenzte Beurteilbarkeit</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è R√ºcken:</strong> 38.1¬∞C</p>
                        <p><strong>üí™ Muskulatur:</strong> 38.4¬∞C</p>
                        <p><strong>ü¶¥ Wirbels√§ule:</strong> 37.9¬∞C</p>
                        <p><em>Keine Entz√ºndungszeichen</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>üß† R√ºckenmark:</strong> T2 hyperintens</p>
                        <p><strong>üíø Bandscheiben:</strong> T2 Signal erhalten</p>
                        <p><strong>ü¶¥ Wirbelk√∂rper:</strong> Normale Signale</p>
                        <p><em>Keine Kompression oder L√§sionen</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>ü¶¥ Wirbelk√∂rper:</strong> 150-300 HU</p>
                        <p><strong>üíø Bandscheiben:</strong> 80-120 HU</p>
                        <p><strong>üß† Spinalkanal:</strong> Frei</p>
                        <p><em>Kn√∂cherne Strukturen intakt</em></p>
                    `;
                default:
                    return `
                        <p><strong>ü¶¥ Wirbels√§ule:</strong> Beweglich</p>
                        <p><strong>üí™ Muskulatur:</strong> Kr√§ftig, symmetrisch</p>
                        <p><strong>üß† Neurologie:</strong> Reflexe normal</p>
                        <p><strong>üö∂ Mobilit√§t:</strong> Uneingeschr√§nkt</p>
                    `;
            }
        }

        function getLimbDetails(mode) {
            switch(mode) {
                case 'xray':
                    return `
                        <p><strong>ü¶¥ R√∂hrenknochen:</strong> Intakt, normale Dichte</p>
                        <p><strong>üîó Gelenke:</strong> Gelenkspalt erhalten</p>
                        <p><strong>ü¶∂ Pfoten:</strong> Alle Zehen vorhanden</p>
                        <p><em>Keine Arthrose oder Frakturen</em></p>
                    `;
                case 'ultrasound':
                    return `
                        <p><strong>üí™ Muskulatur:</strong> Homogene Struktur</p>
                        <p><strong>ü©∏ Gef√§√üe:</strong> Guter Doppler-Fluss</p>
                        <p><strong>ü¶¥ Kortikalis:</strong> Echogen</p>
                        <p><em>Keine H√§matome oder √ñdeme</em></p>
                    `;
                case 'thermal':
                    return `
                        <p><strong>üå°Ô∏è Gliedma√üen:</strong> 37.2¬∞C</p>
                        <p><strong>ü¶∂ Pfoten:</strong> 36.8¬∞C (peripher)</p>
                        <p><strong>üîó Gelenke:</strong> 37.5¬∞C</p>
                        <p><em>Gute periphere Durchblutung</em></p>
                    `;
                case 'mri':
                    return `
                        <p><strong>üí™ Muskulatur:</strong> T1 iso-/hypointens</p>
                        <p><strong>ü¶¥ Knochenmark:</strong> Normale Signale</p>
                        <p><strong>üîó Gelenke:</strong> Knorpel T2 hyperintens</p>
                        <p><em>Keine √ñdeme oder L√§sionen</em></p>
                    `;
                case 'ct':
                    return `
                        <p><strong>ü¶¥ Kortikalis:</strong> 1000+ HU</p>
                        <p><strong>ü¶¥ Spongiosa:</strong> 150-400 HU</p>
                        <p><strong>üí™ Weichteile:</strong> 40-80 HU</p>
                        <p><em>Knochendichte altersgerecht</em></p>
                    `;
                default:
                    return `
                        <p><strong>ü¶¥ Knochen:</strong> Stabil, belastbar</p>
                        <p><strong>üîó Gelenke:</strong> Volle Beweglichkeit</p>
                        <p><strong>üí™ Muskulatur:</strong> Kraftvoll, symmetrisch</p>
                        <p><strong>ü¶∂ Gang:</strong> Physiologisch</p>
                    `;
            }
        }

        function closeOrganInfo() {
            document.getElementById('organ-info').style.display = 'none';
        }

        function onWindowResize() {
            const container = document.getElementById('viewer-canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            if (controls && controls.update) {
                controls.update();
            } else if (window.fallbackRotation && belloModel) {
                // Fallback auto-rotation
                belloModel.rotation.y += 0.005;
            }
            
            // Update shader uniforms
            const time = performance.now() * 0.001;
            if (medicalShaders.ultrasound.uniforms) {
                medicalShaders.ultrasound.uniforms.time.value = time;
            }
            if (medicalShaders.thermal.uniforms) {
                medicalShaders.thermal.uniforms.time.value = time;
            }
            if (medicalShaders.mri.uniforms) {
                medicalShaders.mri.uniforms.slice.value = Math.sin(time) * 0.5;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>