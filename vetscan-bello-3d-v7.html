<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VetScan Pro - Bello 3D Scanner v7.0.2</title>
    <!-- Three.js Core - unpkg CDN (funktioniert garantiert!) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <!-- Three.js Examples - unpkg CDN mit korrekten Pfaden -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .main-viewer {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        #viewer-canvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            background: #0f0f23;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .controls-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .mode-buttons .mode-button:nth-child(5) {
            grid-column: 1 / -1;
        }

        .mode-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f0f0f0;
        }

        .mode-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .mode-button.active {
            background: #667eea;
            color: white;
        }

        .organ-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
            max-width: 250px;
            display: none;
        }

        .organ-info h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .organ-info p {
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 5px;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 10px;
            color: white;
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #667eea;
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .help-text {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            text-align: center;
        }

        .status-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
        }

        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: lime;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üêï VetScan Pro - Bello 3D Scanner</h1>
            <p>Interaktive 3D-Untersuchung mit medizinischen Visualisierungen</p>
            <p style="font-size: 12px; opacity: 0.7;">Version 7.0.2 - Build 2025.08.23.002</p>
        </header>

        <div class="main-viewer">
            <div id="loading-overlay" class="loading-overlay">
                <div>
                    <div>üêï Lade Bello Modell...</div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text">0%</div>
                </div>
            </div>

            <div class="controls-panel">
                <h3>üî¨ Untersuchungsmodi</h3>
                <div class="mode-buttons">
                    <button class="mode-button active" onclick="switchVisualization('normal')" title="Standard-Ansicht">
                        üëÅÔ∏è Normal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('xray')" title="R√∂ntgenbild">
                        ü¶¥ R√∂ntgen
                    </button>
                    <button class="mode-button" onclick="switchVisualization('ultrasound')" title="Ultraschall">
                        üì° Ultraschall
                    </button>
                    <button class="mode-button" onclick="switchVisualization('thermal')" title="W√§rmebild">
                        üå°Ô∏è Thermal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('mri')" title="Magnetresonanztomographie">
                        üß† MRT
                    </button>
                </div>
            </div>

            <div id="organ-info" class="organ-info">
                <h4 id="organ-title">K√∂rperbereich</h4>
                <div id="organ-details">
                    <p>Klicken Sie auf einen Bereich des Hundes f√ºr Details.</p>
                </div>
                <button onclick="closeOrganInfo()" style="margin-top: 10px; padding: 5px 10px; background: #f0f0f0; border: none; border-radius: 5px; cursor: pointer;">Schlie√üen</button>
            </div>

            <div class="help-text">
                üñ±Ô∏è Klicken zum Untersuchen ‚Ä¢ Ziehen zum Drehen ‚Ä¢ Scroll zum Zoomen
            </div>

            <div id="viewer-canvas"></div>
            
            <div class="status-badge">v7.0.2</div>
        </div>

        <div class="debug-info" id="debug-info">
            Loading libraries...<br>
            Version: 7.0.2<br>
            Build: 2025.08.23.002
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let belloModel = null;
        let currentVisualization = 'normal';
        let medicalShaders = {};
        let originalMaterials = new Map();
        let loadingProgress = 0;
        const VERSION = '7.0.2';
        const BUILD = '2025.08.23.002';

        // Debug helper
        function debug(message) {
            console.log(`[v${VERSION}] ${message}`);
            const debugEl = document.getElementById('debug-info');
            if (debugEl) {
                debugEl.innerHTML += `<br>${message}`;
                // Keep only last 10 messages
                const lines = debugEl.innerHTML.split('<br>');
                if (lines.length > 10) {
                    debugEl.innerHTML = lines.slice(-10).join('<br>');
                }
            }
        }

        // Robust library loader with multiple fallbacks
        function waitForLibraries(callback, attempts = 0) {
            debug(`Checking libraries (attempt ${attempts + 1})...`);
            
            // Check if all libraries are loaded
            const checks = {
                'THREE': typeof THREE !== 'undefined',
                'OrbitControls': typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined',
                'GLTFLoader': typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined',
                'DRACOLoader': typeof THREE !== 'undefined' && typeof THREE.DRACOLoader !== 'undefined'
            };
            
            debug(`Library status: ${JSON.stringify(checks)}`);
            
            // All libraries loaded successfully
            if (checks.THREE && checks.OrbitControls && checks.GLTFLoader && checks.DRACOLoader) {
                debug('‚úÖ All libraries loaded successfully!');
                callback();
                return;
            }
            
            // Try to fix missing libraries
            if (checks.THREE && !checks.OrbitControls) {
                // OrbitControls might be on window
                if (typeof OrbitControls !== 'undefined') {
                    THREE.OrbitControls = OrbitControls;
                    debug('üì¶ Fixed: OrbitControls from global');
                }
            }
            
            if (checks.THREE && !checks.GLTFLoader) {
                if (typeof GLTFLoader !== 'undefined') {
                    THREE.GLTFLoader = GLTFLoader;
                    debug('üì¶ Fixed: GLTFLoader from global');
                }
            }
            
            if (checks.THREE && !checks.DRACOLoader) {
                if (typeof DRACOLoader !== 'undefined') {
                    THREE.DRACOLoader = DRACOLoader;
                    debug('üì¶ Fixed: DRACOLoader from global');
                }
            }
            
            // Retry after a delay
            if (attempts < 20) { // Try for up to 10 seconds
                setTimeout(() => waitForLibraries(callback, attempts + 1), 500);
            } else {
                debug('‚ùå Failed to load all libraries after 10 seconds');
                document.getElementById('loading-overlay').innerHTML = 
                    '<div style="color: red; padding: 20px;">‚ùå Fehler beim Laden der 3D-Bibliotheken. Bitte Seite neu laden (F5).</div>';
            }
        }

        // Initialize when ready
        window.addEventListener('load', function() {
            debug(`Starting VetScan Pro v${VERSION}...`);
            waitForLibraries(() => {
                debug('üéÆ Initializing 3D scene...');
                init();
            });
        });

        function init() {
            try {
                setupScene();
                setupCamera();
                setupRenderer();
                setupLights();
                setupControls();
                setupShaders();
                loadBelloModel();
                animate();

                // Resize Handler
                window.addEventListener('resize', onWindowResize);
                debug('‚úÖ Initialization complete');
            } catch (error) {
                debug('‚ùå Initialization error: ' + error.message);
                console.error(error);
            }
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f23);
            debug('Scene created');
        }

        function setupCamera() {
            const container = document.getElementById('viewer-canvas');
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 4);
            debug('Camera configured');
        }

        function setupRenderer() {
            const container = document.getElementById('viewer-canvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            debug('Renderer initialized');
        }

        function setupLights() {
            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Directional Light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Spot Light
            const spotLight = new THREE.SpotLight(0x0099ff, 0.5);
            spotLight.position.set(-5, 5, 5);
            spotLight.angle = Math.PI / 6;
            scene.add(spotLight);
            debug('Lights configured');
        }

        function setupControls() {
            try {
                // Use THREE.OrbitControls which we ensured exists
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 2;
                controls.maxDistance = 20;
                controls.maxPolarAngle = Math.PI / 2;

                // Click Handler
                renderer.domElement.addEventListener('click', onCanvasClick);
                debug('OrbitControls initialized');
            } catch (error) {
                debug('‚ùå OrbitControls error: ' + error.message);
                // Fallback to auto-rotation
                setupFallbackControls();
            }
        }

        function setupFallbackControls() {
            debug('‚ö†Ô∏è Using fallback rotation');
            window.fallbackRotation = true;
        }

        function setupShaders() {
            // Enhanced X-Ray Shader (Medical Grade)
            medicalShaders.xray = {
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.0);
                        
                        vec3 xrayColor = vec3(0.7, 0.9, 1.0);
                        vec3 boneColor = vec3(0.95, 0.95, 0.9);
                        
                        vec3 color = mix(boneColor, xrayColor, fresnel);
                        float alpha = 0.3 + fresnel * 0.7;
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            };

            // Ultrasound Shader
            medicalShaders.ultrasound = {
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vUv = uv;
                        vPosition = position;
                        vec3 pos = position;
                        pos.y += sin(time * 2.0 + position.x * 5.0) * 0.02;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        vec2 scanLine = vec2(vUv.x, mod(vUv.y + time * 0.1, 1.0));
                        float noise = random(scanLine + time);
                        
                        vec3 baseColor = vec3(0.1, 0.1, 0.2);
                        vec3 echoColor = vec3(0.3, 0.6, 0.9);
                        
                        float echo = sin(vUv.y * 50.0 + time * 2.0) * 0.5 + 0.5;
                        echo *= noise;
                        
                        vec3 color = mix(baseColor, echoColor, echo);
                        
                        float scanEffect = smoothstep(0.0, 0.1, abs(mod(vUv.y + time * 0.1, 1.0) - 0.5));
                        color += vec3(0.2) * (1.0 - scanEffect);
                        
                        gl_FragColor = vec4(color, 0.9);
                    }
                `,
                uniforms: {
                    time: { value: 0 }
                }
            };

            // Thermal Imaging Shader
            medicalShaders.thermal = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float time;
                    
                    vec3 heatmap(float t) {
                        vec3 cold = vec3(0.0, 0.0, 1.0);
                        vec3 cool = vec3(0.0, 1.0, 1.0);
                        vec3 warm = vec3(1.0, 1.0, 0.0);
                        vec3 hot = vec3(1.0, 0.0, 0.0);
                        
                        if (t < 0.33) return mix(cold, cool, t * 3.0);
                        else if (t < 0.66) return mix(cool, warm, (t - 0.33) * 3.0);
                        else return mix(warm, hot, (t - 0.66) * 3.0);
                    }
                    
                    void main() {
                        float heat = (vPosition.y + 1.0) * 0.5;
                        heat += sin(time + vPosition.x * 5.0) * 0.1;
                        heat += sin(time * 1.5 + vPosition.z * 3.0) * 0.1;
                        heat = clamp(heat, 0.0, 1.0);
                        
                        vec3 color = heatmap(heat);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                uniforms: {
                    time: { value: 0 }
                }
            };

            // MRI Shader
            medicalShaders.mri = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    uniform float slice;
                    
                    void main() {
                        float intensity = 0.5 + 0.5 * dot(vNormal, vec3(0.0, 1.0, 0.0));
                        
                        // Cross-section effect
                        float sliceEffect = smoothstep(0.0, 0.1, abs(vPosition.y - slice));
                        intensity *= sliceEffect;
                        
                        // Tissue differentiation
                        float tissue1 = sin(vPosition.x * 10.0) * 0.1;
                        float tissue2 = cos(vPosition.z * 8.0) * 0.1;
                        intensity += tissue1 + tissue2;
                        
                        vec3 color = vec3(intensity);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                uniforms: {
                    slice: { value: 0 }
                }
            };
            
            debug('Medical shaders configured');
        }

        function loadBelloModel() {
            updateProgress(10);
            
            // Try to load GLTF model first
            const loader = new THREE.GLTFLoader();
            
            // Configure DRACO decoder (optional, for compressed models)
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            loader.setDRACOLoader(dracoLoader);
            
            // Model URLs in priority order
            const modelUrls = [
                'assets/models/animals/bello/bello_medium.glb',
                'assets/models/animals/bello/bello_low.glb',
                'assets/models/animals/bello/bello.glb',
                'assets/models/bello.glb',
                'models/bello.glb'
            ];
            
            let modelLoadAttempt = 0;
            
            function tryLoadModel() {
                if (modelLoadAttempt >= modelUrls.length) {
                    debug('‚ö†Ô∏è No GLB models found, using procedural dog');
                    createProceduralDog();
                    return;
                }
                
                const url = modelUrls[modelLoadAttempt];
                debug(`Attempting to load: ${url}`);
                updateProgress(20 + modelLoadAttempt * 10);
                
                loader.load(
                    url,
                    function(gltf) {
                        debug(`‚úÖ Model loaded: ${url}`);
                        belloModel = gltf.scene;
                        
                        // Store original materials
                        belloModel.traverse((child) => {
                            if (child.isMesh) {
                                originalMaterials.set(child, child.material.clone());
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        // Center and scale
                        const box = new THREE.Box3().setFromObject(belloModel);
                        const center = box.getCenter(new THREE.Vector3());
                        belloModel.position.sub(center);
                        
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 3 / maxDim;
                        belloModel.scale.setScalar(scale);
                        
                        scene.add(belloModel);
                        updateProgress(100);
                        hideLoadingOverlay();
                    },
                    function(xhr) {
                        const percent = (xhr.loaded / xhr.total * 100);
                        updateProgress(20 + modelLoadAttempt * 10 + percent * 0.7);
                    },
                    function(error) {
                        debug(`Failed to load ${url}`);
                        modelLoadAttempt++;
                        tryLoadModel();
                    }
                );
            }
            
            tryLoadModel();
        }

        function createProceduralDog() {
            debug('Creating procedural Bello model...');
            const dogGroup = new THREE.Group();
            
            // Enhanced Body
            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            bodyGeometry.scale(1.2, 0.8, 0.9);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B6F47,
                emissive: 0x4A3C28,
                emissiveIntensity: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0;
            body.castShadow = true;
            body.receiveShadow = true;
            dogGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.6, 32, 32);
            headGeometry.scale(0.9, 0.9, 1.1);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B6F47,
                emissive: 0x4A3C28,
                emissiveIntensity: 0.1
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.2, 0.3, 0);
            head.castShadow = true;
            dogGroup.add(head);
            
            // Snout
            const snoutGeometry = new THREE.ConeGeometry(0.3, 0.6, 16);
            snoutGeometry.rotateZ(-Math.PI / 2);
            const snoutMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x6B5637
            });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(1.7, 0.2, 0);
            dogGroup.add(snout);
            
            // Ears
            const earGeometry = new THREE.ConeGeometry(0.25, 0.5, 8);
            const earMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x5C4A3A
            });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(1.1, 0.8, -0.3);
            leftEar.rotation.z = -0.3;
            dogGroup.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial.clone());
            rightEar.position.set(1.1, 0.8, 0.3);
            rightEar.rotation.z = -0.3;
            dogGroup.add(rightEar);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                emissive: 0x111111,
                emissiveIntensity: 0.5
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(1.4, 0.4, -0.2);
            dogGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
            rightEye.position.set(1.4, 0.4, 0.2);
            dogGroup.add(rightEye);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.8, 12);
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x7A5F3F
            });
            
            const positions = [
                [0.5, -0.6, -0.3],
                [0.5, -0.6, 0.3],
                [-0.5, -0.6, -0.3],
                [-0.5, -0.6, 0.3]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial.clone());
                leg.position.set(...pos);
                leg.castShadow = true;
                dogGroup.add(leg);
            });
            
            // Tail
            const tailGeometry = new THREE.ConeGeometry(0.2, 0.8, 12);
            tailGeometry.rotateZ(Math.PI / 3);
            const tailMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x6B5637
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-1.3, 0.2, 0);
            dogGroup.add(tail);
            
            // Store materials for shader switching
            dogGroup.traverse((child) => {
                if (child.isMesh) {
                    originalMaterials.set(child, child.material.clone());
                }
            });
            
            belloModel = dogGroup;
            scene.add(belloModel);
            
            updateProgress(100);
            hideLoadingOverlay();
            debug('‚úÖ Procedural dog created');
        }

        function updateProgress(percent) {
            loadingProgress = percent;
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            if (progressFill) progressFill.style.width = percent + '%';
            if (progressText) progressText.textContent = Math.round(percent) + '%';
        }

        function hideLoadingOverlay() {
            setTimeout(() => {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) overlay.style.display = 'none';
                debug('Ready for interaction');
            }, 500);
        }

        function switchVisualization(mode) {
            currentVisualization = mode;
            debug(`Switching to ${mode} mode`);
            
            // Update button states
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (!belloModel) return;
            
            // Apply visualization
            belloModel.traverse((child) => {
                if (child.isMesh) {
                    if (mode === 'normal') {
                        child.material = originalMaterials.get(child) || child.material;
                    } else if (medicalShaders[mode]) {
                        const shaderMaterial = new THREE.ShaderMaterial({
                            vertexShader: medicalShaders[mode].vertexShader,
                            fragmentShader: medicalShaders[mode].fragmentShader,
                            uniforms: medicalShaders[mode].uniforms || {},
                            transparent: medicalShaders[mode].transparent || false,
                            side: medicalShaders[mode].side || THREE.FrontSide
                        });
                        child.material = shaderMaterial;
                    }
                }
            });
        }

        function onCanvasClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            if (belloModel) {
                const intersects = raycaster.intersectObject(belloModel, true);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    showOrganInfo(point);
                }
            }
        }

        function showOrganInfo(point) {
            const organInfo = document.getElementById('organ-info');
            const organTitle = document.getElementById('organ-title');
            const organDetails = document.getElementById('organ-details');
            
            // Determine body region based on click position
            let region = 'K√∂rper';
            let details = '';
            
            if (point.y > 0.5) {
                region = 'Kopf & Hals';
                details = `
                    <p><strong>Gehirn:</strong> Neurologische Funktionen normal</p>
                    <p><strong>Augen:</strong> Pupillenreaktion positiv</p>
                    <p><strong>Ohren:</strong> Keine Entz√ºndungen erkennbar</p>
                `;
            } else if (point.y > -0.2) {
                if (point.x > 0.3) {
                    region = 'Brustkorb';
                    details = `
                        <p><strong>Herz:</strong> 80 BPM, rhythmisch</p>
                        <p><strong>Lunge:</strong> Klare Atemger√§usche</p>
                        <p><strong>Rippen:</strong> Intakt, keine Frakturen</p>
                    `;
                } else {
                    region = 'Bauchraum';
                    details = `
                        <p><strong>Magen:</strong> Normale F√ºllung</p>
                        <p><strong>Leber:</strong> Gr√∂√üe normal</p>
                        <p><strong>Nieren:</strong> Beide funktionsf√§hig</p>
                    `;
                }
            } else {
                region = 'Extremit√§ten';
                details = `
                    <p><strong>Knochen:</strong> Keine Frakturen</p>
                    <p><strong>Gelenke:</strong> Beweglichkeit gut</p>
                    <p><strong>Muskulatur:</strong> Tonus normal</p>
                `;
            }
            
            organTitle.textContent = region;
            organDetails.innerHTML = details;
            organInfo.style.display = 'block';
        }

        function closeOrganInfo() {
            document.getElementById('organ-info').style.display = 'none';
        }

        function onWindowResize() {
            const container = document.getElementById('viewer-canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            if (controls && controls.update) {
                controls.update();
            } else if (window.fallbackRotation && belloModel) {
                // Fallback auto-rotation
                belloModel.rotation.y += 0.005;
            }
            
            // Update shader uniforms
            const time = performance.now() * 0.001;
            if (medicalShaders.ultrasound.uniforms) {
                medicalShaders.ultrasound.uniforms.time.value = time;
            }
            if (medicalShaders.thermal.uniforms) {
                medicalShaders.thermal.uniforms.time.value = time;
            }
            if (medicalShaders.mri.uniforms) {
                medicalShaders.mri.uniforms.slice.value = Math.sin(time) * 0.5;
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>