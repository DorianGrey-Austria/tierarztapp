<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VetScan Pro - Bello 3D Scanner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .main-viewer {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        #viewer-canvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            background: #0f0f23;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .controls-panel h3 {
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .mode-buttons .mode-button:nth-child(5) {
            grid-column: 1 / -1;
        }

        .mode-button {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f0f0f0;
        }

        .mode-button:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
        }

        .mode-button.active {
            background: #667eea;
            color: white;
        }

        .organ-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            display: none;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 10px;
            z-index: 20;
        }

        .progress-bar {
            width: 200px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.3s;
        }

        .help-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .diagnostic-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .vital-signs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .vital-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .error-panel {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            color: #d32f2f;
        }

        @media (max-width: 768px) {
            .mode-buttons {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                position: static;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üêï VetScan Pro - Bello 3D Scanner</h1>
            <p>Interaktive 3D-Untersuchung mit medizinischen Visualisierungen</p>
        </header>

        <div class="main-viewer">
            <div id="loading-overlay" class="loading-overlay">
                <div>
                    <div>üêï Lade Bello Modell...</div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text">0%</div>
                </div>
            </div>

            <div class="controls-panel">
                <h3>üî¨ Untersuchungsmodi</h3>
                <div class="mode-buttons">
                    <button class="mode-button active" onclick="switchVisualization('normal')" title="Standard-Ansicht">
                        üëÅÔ∏è Normal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('xray')" title="R√∂ntgenbild">
                        ü¶¥ R√∂ntgen
                    </button>
                    <button class="mode-button" onclick="switchVisualization('ultrasound')" title="Ultraschall">
                        üì° Ultraschall
                    </button>
                    <button class="mode-button" onclick="switchVisualization('thermal')" title="W√§rmebild">
                        üå°Ô∏è Thermal
                    </button>
                    <button class="mode-button" onclick="switchVisualization('mri')" title="Magnetresonanztomographie">
                        üß† MRT
                    </button>
                </div>
            </div>

            <div id="organ-info" class="organ-info">
                <h4 id="organ-title">K√∂rperbereich</h4>
                <div id="organ-details">
                    <p>Klicken Sie auf einen Bereich des Hundes f√ºr Details.</p>
                </div>
                <button onclick="closeOrganInfo()" style="margin-top: 10px; padding: 5px 10px; background: #f0f0f0; border: none; border-radius: 5px; cursor: pointer;">Schlie√üen</button>
            </div>

            <div class="help-text">
                üñ±Ô∏è Klicken zum Untersuchen ‚Ä¢ Ziehen zum Drehen ‚Ä¢ Scroll zum Zoomen
            </div>

            <div id="viewer-canvas"></div>
        </div>

        <div class="diagnostic-panel">
            <h2>ü©∫ Diagnostik-Dashboard</h2>
            <div class="vital-signs">
                <div class="vital-card">
                    <h4>‚ù§Ô∏è Herzfrequenz</h4>
                    <p id="heart-rate">85 BPM (Normal: 60-140)</p>
                </div>
                <div class="vital-card">
                    <h4>üå°Ô∏è K√∂rpertemperatur</h4>
                    <p id="temperature">38.5¬∞C (Normal: 37.5-39.2¬∞C)</p>
                </div>
                <div class="vital-card">
                    <h4>ü´Å Atemfrequenz</h4>
                    <p id="respiratory-rate">22/min (Normal: 15-30)</p>
                </div>
                <div class="vital-card">
                    <h4>üíâ Blutdruck</h4>
                    <p id="blood-pressure">130/80 mmHg (Normal: 110-160)</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Globale Variablen
        let scene, camera, renderer, controls;
        let currentModel = null;
        let currentVisualizationMode = 'normal';
        let medicalShaders = {};
        let originalMaterials = new Map();
        let isLoading = true;

        // Initialisierung
        init();

        function init() {
            setupScene();
            setupCamera();
            setupRenderer();
            setupLights();
            setupControls();
            setupShaders();
            loadBelloModel();
            animate();

            // Resize Handler
            window.addEventListener('resize', onWindowResize);
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f23);
        }

        function setupCamera() {
            const container = document.getElementById('viewer-canvas');
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 4);
        }

        function setupRenderer() {
            const container = document.getElementById('viewer-canvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
        }

        function setupLights() {
            // Ambient Light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Directional Light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Spot Light
            const spotLight = new THREE.SpotLight(0x0099ff, 0.5);
            spotLight.position.set(-5, 5, 5);
            spotLight.angle = Math.PI / 6;
            scene.add(spotLight);
        }

        function setupControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 2;

            // Click Handler
            renderer.domElement.addEventListener('click', onCanvasClick);
        }

        function setupShaders() {
            // Enhanced X-Ray Shader (Medical Grade)
            medicalShaders.xray = {
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    
                    // Medical X-Ray density simulation
                    float getBoneDensity(vec3 pos, vec3 normal) {
                        // Simulate bone density based on position and normal
                        float centralBone = length(pos.xz) < 0.5 ? 1.0 : 0.3;
                        float edgeBone = 1.0 - smoothstep(0.0, 0.8, length(pos.xz));
                        return centralBone * edgeBone;
                    }
                    
                    void main() {
                        vec3 viewDirection = normalize(-vPosition);
                        float fresnel = pow(1.0 - max(0.0, dot(viewDirection, vNormal)), 2.0);
                        
                        // Medical X-Ray simulation
                        float boneDensity = getBoneDensity(vWorldPosition, vNormal);
                        float tissueTransparency = 1.0 - boneDensity;
                        
                        // Realistic X-Ray colors
                        vec3 boneColor = vec3(0.9, 0.95, 1.0);    // Bright white for bones
                        vec3 tissueColor = vec3(0.1, 0.15, 0.3);   // Dark for soft tissue
                        vec3 backgroundColor = vec3(0.05, 0.05, 0.1); // Near black
                        
                        // Mix colors based on density
                        vec3 xrayColor = mix(backgroundColor, tissueColor, tissueTransparency * 0.3);
                        xrayColor = mix(xrayColor, boneColor, boneDensity * fresnel);
                        
                        // Add subtle scan lines for realism
                        float scanLine = sin(vWorldPosition.y * 50.0 + time * 2.0) * 0.1 + 1.0;
                        xrayColor *= scanLine;
                        
                        float alpha = 0.85;
                        gl_FragColor = vec4(xrayColor, alpha);
                    }
                `
            };

            // Enhanced Ultrasound Shader (Medical Grade)
            medicalShaders.ultrasound = {
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vUv = uv;
                        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    
                    // Advanced noise functions for ultrasound texture
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                                   mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                    }
                    
                    float fbm(vec2 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        for(int i = 0; i < 4; i++) {
                            value += amplitude * noise(p);
                            p *= 2.0;
                            amplitude *= 0.5;
                        }
                        return value;
                    }
                    
                    void main() {
                        // Ultrasound beam simulation
                        float depth = length(vPosition) / 6.0;
                        float beamAttenuation = exp(-depth * 0.8);
                        
                        // Multiple scan lines for realistic ultrasound
                        float scanLine1 = sin(vWorldPosition.y * 15.0 + time * 3.0) * 0.5 + 0.5;
                        float scanLine2 = sin(vWorldPosition.y * 25.0 + time * 4.0) * 0.3 + 0.7;
                        float scanLine3 = sin(vWorldPosition.y * 35.0 + time * 2.0) * 0.2 + 0.8;
                        
                        // Ultrasound speckle pattern
                        vec2 speckleUV = vUv * 80.0 + time * 0.1;
                        float speckle = fbm(speckleUV) * 0.4;
                        
                        // Tissue reflection simulation
                        vec3 viewDir = normalize(-vPosition);
                        float reflection = dot(vNormal, viewDir);
                        float tissueReflection = smoothstep(0.2, 0.8, reflection);
                        
                        // Combine effects
                        float intensity = scanLine1 * scanLine2 * scanLine3;
                        intensity *= beamAttenuation;
                        intensity *= (0.7 + speckle);
                        intensity *= (0.3 + tissueReflection * 0.7);
                        
                        // Medical ultrasound color palette (grayscale with slight blue tint)
                        vec3 ultrasoundColor = vec3(intensity * 0.9, intensity * 0.95, intensity);
                        
                        // Add brightness boost for visible structures
                        ultrasoundColor += vec3(tissueReflection * 0.2);
                        
                        gl_FragColor = vec4(ultrasoundColor, 1.0);
                    }
                `
            };

            // Enhanced Thermal Shader (Medical Grade)
            medicalShaders.thermal = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    
                    // Medical thermal imaging simulation
                    float getBodyTemperature(vec3 worldPos, vec3 normal) {
                        // Core body temperature (higher in center, lower at extremities)
                        float distanceFromCore = length(worldPos.xz);
                        float coreTemp = 1.0 - smoothstep(0.0, 1.5, distanceFromCore);
                        
                        // Surface temperature based on blood flow (normal direction)
                        float surfaceFlow = dot(normal, normalize(vec3(0, 1, 0))) * 0.5 + 0.5;
                        
                        // Heart rate simulation (pulsing warmth)
                        float heartBeat = sin(time * 6.28) * 0.1 + 0.9; // ~60 BPM
                        
                        // Breathing effect (subtle chest movement warmth)
                        float breathingCycle = sin(time * 1.5) * 0.05 + 0.95; // ~22.5 breaths/min
                        
                        // Combine temperature factors
                        float baseTemp = 0.6; // Normal body temperature base
                        float temperature = baseTemp + coreTemp * 0.3 + surfaceFlow * 0.1;
                        temperature *= heartBeat * breathingCycle;
                        
                        return clamp(temperature, 0.0, 1.0);
                    }
                    
                    // Medical thermal color palette (FLIR-style)
                    vec3 medicalHeatColor(float temperature) {
                        // Purple to Red thermal medical palette
                        if (temperature < 0.15) {
                            // Hypothermic - Purple to Blue
                            return mix(vec3(0.2, 0.0, 0.4), vec3(0.0, 0.0, 0.8), temperature / 0.15);
                        } else if (temperature < 0.35) {
                            // Cool - Blue to Cyan
                            return mix(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.8, 1.0), (temperature - 0.15) / 0.2);
                        } else if (temperature < 0.55) {
                            // Normal - Cyan to Green
                            return mix(vec3(0.0, 0.8, 1.0), vec3(0.0, 1.0, 0.2), (temperature - 0.35) / 0.2);
                        } else if (temperature < 0.75) {
                            // Warm - Green to Yellow
                            return mix(vec3(0.0, 1.0, 0.2), vec3(1.0, 1.0, 0.0), (temperature - 0.55) / 0.2);
                        } else if (temperature < 0.9) {
                            // Hot - Yellow to Orange
                            return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.5, 0.0), (temperature - 0.75) / 0.15);
                        } else {
                            // Fever - Orange to Red
                            return mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.0, 0.0), (temperature - 0.9) / 0.1);
                        }
                    }
                    
                    void main() {
                        float temperature = getBodyTemperature(vWorldPosition, vNormal);
                        vec3 thermalColor = medicalHeatColor(temperature);
                        
                        // Add subtle thermal gradient overlay
                        float gradientY = (vWorldPosition.y + 2.0) / 4.0;
                        thermalColor *= (0.8 + gradientY * 0.2);
                        
                        gl_FragColor = vec4(thermalColor, 1.0);
                    }
                `
            };

            // NEW: MRI Shader (Medical Grade)
            medicalShaders.mri = {
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    uniform float time;
                    
                    // MRI tissue contrast simulation
                    float getTissueContrast(vec3 worldPos, vec3 normal) {
                        // Distance from core (different tissue densities)
                        float distanceFromCore = length(worldPos.xz);
                        
                        // Bone tissue (high signal intensity)
                        float boneSignal = 1.0 - smoothstep(0.0, 0.4, distanceFromCore);
                        
                        // Soft tissue (medium signal intensity)  
                        float softTissue = smoothstep(0.2, 0.8, distanceFromCore) * 
                                          (1.0 - smoothstep(0.8, 1.2, distanceFromCore));
                        
                        // Fat tissue (bright in T1, dark in T2)
                        float fatTissue = smoothstep(0.6, 1.0, distanceFromCore) * 0.8;
                        
                        // Surface detail enhancement
                        float surfaceDetail = abs(dot(normal, normalize(vec3(1, 1, 1))));
                        
                        return boneSignal * 0.9 + softTissue * 0.5 + fatTissue * 0.3 + surfaceDetail * 0.2;
                    }
                    
                    void main() {
                        float tissueIntensity = getTissueContrast(vWorldPosition, vNormal);
                        
                        // MRI gradient echo simulation
                        float gradientPhase = sin(vWorldPosition.y * 8.0 + time * 0.5) * 0.1 + 0.9;
                        tissueIntensity *= gradientPhase;
                        
                        // Medical MRI grayscale with high contrast
                        float mriIntensity = pow(tissueIntensity, 1.2); // Increase contrast
                        vec3 mriColor = vec3(mriIntensity);
                        
                        // Add subtle blue tint for medical realism
                        mriColor.b += 0.1 * mriIntensity;
                        
                        gl_FragColor = vec4(mriColor, 1.0);
                    }
                `
            };
        }

        function loadBelloModel() {
            // Progressive Loading: Try to load real Bello GLB files from Blender export
            const qualityLevels = ['high', 'medium', 'low'];
            let currentQualityIndex = 0;

            updateLoadingProgress(10, 'Suche nach Bello 3D-Modell...');

            function tryLoadNextQuality() {
                if (currentQualityIndex >= qualityLevels.length) {
                    // No GLB files found, use enhanced fallback
                    updateLoadingProgress(50, 'Erstelle procedurales Bello-Modell...');
                    createFallbackDog();
                    return;
                }

                const quality = qualityLevels[currentQualityIndex];
                const modelPath = `./assets/models/animals/bello/bello_${quality}.glb`;
                
                updateLoadingProgress(20 + (currentQualityIndex * 10), `Lade ${quality} quality...`);
                
                const loader = new THREE.GLTFLoader();
                const dracoLoader = new THREE.DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                loader.setDRACOLoader(dracoLoader);

                loader.load(
                    modelPath,
                    // Success - found real Bello model
                    function(gltf) {
                        updateLoadingProgress(80, `Bello ${quality} quality geladen!`);
                        
                        const model = gltf.scene;
                        model.name = 'bello';
                        model.scale.setScalar(2); // Scale to match fallback size
                        
                        // Setup shadows
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                originalMaterials.set(child.uuid, child.material.clone());
                            }
                        });

                        scene.add(model);
                        currentModel = model;
                        setupInteractiveZones(model);
                        hideLoading();
                        
                        console.log(`üêï Real Bello model loaded (${quality} quality)`);
                        console.log(`üìä Polygons: ${countPolygons(model)}`);
                    },
                    // Progress
                    function(progress) {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        updateLoadingProgress(50 + (percent / 4), `L√§dt ${quality}... ${percent}%`);
                    },
                    // Error - try next quality or fallback
                    function(error) {
                        console.log(`‚ö†Ô∏è Could not load ${quality} quality:`, error.message);
                        currentQualityIndex++;
                        tryLoadNextQuality();
                    }
                );
            }

            // Start progressive loading
            tryLoadNextQuality();
        }

        function updateLoadingProgress(percent, message) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            if (progressFill) {
                progressFill.style.width = percent + '%';
            }
            if (progressText) {
                progressText.textContent = `${Math.round(percent)}%`;
            }
            
            // Update loading message - improved stability
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay && message) {
                const messageEl = loadingOverlay.querySelector('div') || loadingOverlay;
                try {
                    messageEl.innerHTML = `üêï ${message}<br><div class="progress-bar"><div id="progress-fill" class="progress-fill" style="width: ${percent}%"></div></div><div id="progress-text">${Math.round(percent)}%</div>`;
                } catch(e) {
                    console.log('Loading progress update:', message);
                }
            }
        }

        function countPolygons(model) {
            let triangles = 0;
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    if (child.geometry.index) {
                        triangles += child.geometry.index.count / 3;
                    } else {
                        triangles += child.geometry.attributes.position.count / 3;
                    }
                }
            });
            return Math.round(triangles);
        }

        function createFallbackDog() {
            try {
                updateLoadingProgress(60, 'Erstelle Enhanced Bello-Modell...');
                
                const dog = new THREE.Group();
                dog.name = 'bello';

            // Enhanced Body (more realistic shape) - r128 compatible
            const bodyGeometry = new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0, 0);
            body.rotation.z = Math.PI / 2;
            body.name = 'body';

            // Enhanced Head (more dog-like)
            const headGeometry = new THREE.SphereGeometry(0.5, 12, 8);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7,
                metalness: 0.1
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.3, 0.1, 0);
            head.name = 'head';

            // Add snout
            const snoutGeometry = new THREE.ConeGeometry(0.2, 0.4, 8);
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.position.set(1.7, -0.1, 0);
            snout.rotation.z = Math.PI / 2;
            snout.name = 'snout';

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.08, 6, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(1.5, 0.2, 0.2);
            leftEye.name = 'left_eye';
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(1.5, 0.2, -0.2);
            rightEye.name = 'right_eye';

            // Ears
            const earGeometry = new THREE.ConeGeometry(0.15, 0.4, 6);
            const earMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(1.1, 0.4, 0.3);
            leftEar.rotation.z = -Math.PI / 6;
            leftEar.name = 'left_ear';
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(1.1, 0.4, -0.3);
            rightEar.rotation.z = -Math.PI / 6;
            rightEar.name = 'right_ear';

            // Enhanced Legs (more realistic) - r128 compatible
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const positions = [
                [-0.5, -0.6, 0.25], // front left
                [-0.5, -0.6, -0.25], // front right
                [0.5, -0.6, 0.25],   // back left
                [0.5, -0.6, -0.25]   // back right
            ];

            const legs = [];
            positions.forEach((pos, i) => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.name = `leg${i}`;
                legs.push(leg);
            });

            // Enhanced Tail (more curved)
            const tailGeometry = new THREE.ConeGeometry(0.06, 0.6, 6);
            const tailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.9, 0.4, 0);
            tail.rotation.z = Math.PI / 3;
            tail.name = 'tail';

            // Add all parts to dog group
            dog.add(body, head, snout, leftEye, rightEye, leftEar, rightEar, tail, ...legs);

            updateLoadingProgress(80, 'Konfiguriere Materialien...');

            // Speichere originale Materialien
            dog.traverse((child) => {
                if (child.isMesh) {
                    originalMaterials.set(child.uuid, child.material.clone());
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(dog);
            currentModel = dog;

            updateLoadingProgress(90, 'Setup interaktive Zonen...');

            // Setup interaktive Zonen
            setupInteractiveZones(dog);

            updateLoadingProgress(100, 'Bello bereit f√ºr Untersuchung!');

            // Loading beenden
            setTimeout(() => hideLoading(), 500); // Small delay for smooth UX

            console.log('üêï Enhanced Fallback Bello model created - Production Ready');
            console.log(`üìä Model Stats: ${countPolygons(dog)} triangles`);
            
            } catch(error) {
                console.error('‚ùå Error creating fallback dog:', error);
                updateLoadingProgress(100, 'Fehler beim Laden - Fallback aktiv');
                hideLoading();
                
                // Create minimal fallback
                createMinimalFallback();
            }
        }

        function createMinimalFallback() {
            // Ultra-minimal fallback if enhanced version fails
            const dog = new THREE.Group();
            const geometry = new THREE.BoxGeometry(2, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(geometry, material);
            
            dog.add(body);
            dog.name = 'bello';
            
            scene.add(dog);
            currentModel = dog;
            
            setupInteractiveZones(dog);
            console.log('üîß Minimal fallback dog created');
        }

        function setupInteractiveZones(model) {
            model.interactiveZones = [
                {
                    name: 'Kopf',
                    center: new THREE.Vector3(1.2, 0.2, 0),
                    radius: 0.6,
                    organs: ['Gehirn', 'Augen', 'Ohren', 'Nase'],
                    description: 'Der Kopfbereich enth√§lt wichtige Sinnesorgane und das Gehirn.'
                },
                {
                    name: 'Brust',
                    center: new THREE.Vector3(0.3, 0, 0),
                    radius: 0.8,
                    organs: ['Herz', 'Lunge', 'Speiser√∂hre'],
                    description: 'Der Brustkorb sch√ºtzt die lebenswichtigen Organe Herz und Lunge.'
                },
                {
                    name: 'Bauch',
                    center: new THREE.Vector3(-0.3, 0, 0),
                    radius: 0.8,
                    organs: ['Magen', 'Leber', 'Nieren', 'Darm'],
                    description: 'Im Bauchraum befinden sich die Verdauungsorgane.'
                },
                {
                    name: 'Beine',
                    center: new THREE.Vector3(0, -0.7, 0),
                    radius: 1.2,
                    organs: ['Knochen', 'Gelenke', 'Muskeln'],
                    description: 'Die Beine erm√∂glichen Bewegung und tragen das K√∂rpergewicht.'
                }
            ];
        }

        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
            isLoading = false;
        }

        function switchVisualization(mode) {
            if (!currentModel) return;

            // Update UI
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            currentVisualizationMode = mode;

            if (mode === 'normal') {
                // Zur√ºck zu originalen Materialien
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        const original = originalMaterials.get(child.uuid);
                        if (original) {
                            child.material = original.clone();
                        }
                    }
                });
            } else {
                // Anwenden des gew√§hlten Shaders
                const shader = medicalShaders[mode];
                if (shader) {
                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.ShaderMaterial({
                                vertexShader: shader.vertexShader,
                                fragmentShader: shader.fragmentShader,
                                uniforms: {
                                    time: { value: 0 }
                                },
                                transparent: mode === 'xray',
                                side: THREE.DoubleSide,
                                blending: mode === 'xray' ? THREE.AdditiveBlending : THREE.NormalBlending
                            });
                        }
                    });
                }
            }

            console.log(`üî¨ Switched to ${mode} visualization`);
        }

        function onCanvasClick(event) {
            if (!currentModel || isLoading) return;

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(currentModel, true);
            
            if (intersects.length > 0) {
                const clickPoint = intersects[0].point;
                const zone = findInteractiveZone(clickPoint);
                
                if (zone) {
                    showOrganInfo(zone);
                    updateVitalSigns(zone);
                }
            }
        }

        function findInteractiveZone(point) {
            if (!currentModel.interactiveZones) return null;

            for (const zone of currentModel.interactiveZones) {
                if (point.distanceTo(zone.center) <= zone.radius) {
                    return zone;
                }
            }
            return null;
        }

        function showOrganInfo(zone) {
            const panel = document.getElementById('organ-info');
            const title = document.getElementById('organ-title');
            const details = document.getElementById('organ-details');

            title.textContent = `üìç ${zone.name}`;
            details.innerHTML = `
                <p><strong>Organe:</strong></p>
                <ul>${zone.organs.map(organ => `<li>‚Ä¢ ${organ}</li>`).join('')}</ul>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    ${zone.description}
                </p>
            `;

            panel.style.display = 'block';
        }

        function closeOrganInfo() {
            document.getElementById('organ-info').style.display = 'none';
        }

        function updateVitalSigns(zone) {
            // Simuliere realistische Werte basierend auf der Zone
            const baseValues = {
                'Kopf': { heart: 85, temp: 38.5, resp: 22, bp: '130/80' },
                'Brust': { heart: 92, temp: 38.7, resp: 24, bp: '135/85' },
                'Bauch': { heart: 88, temp: 38.4, resp: 20, bp: '128/78' },
                'Beine': { heart: 85, temp: 38.2, resp: 22, bp: '130/80' }
            };

            const values = baseValues[zone.name] || baseValues['Kopf'];

            document.getElementById('heart-rate').textContent = `${values.heart} BPM (Normal: 60-140)`;
            document.getElementById('temperature').textContent = `${values.temp}¬∞C (Normal: 37.5-39.2¬∞C)`;
            document.getElementById('respiratory-rate').textContent = `${values.resp}/min (Normal: 15-30)`;
            document.getElementById('blood-pressure').textContent = `${values.bp} mmHg (Normal: 110-160)`;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Update shader uniforms
            if (currentModel && currentVisualizationMode !== 'normal') {
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material.uniforms && child.material.uniforms.time) {
                        child.material.uniforms.time.value = time;
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('viewer-canvas');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Initialisiere erste Vitalwerte
        setTimeout(() => {
            updateVitalSigns({ name: 'Kopf' });
        }, 1000);
    </script>
</body>
</html>